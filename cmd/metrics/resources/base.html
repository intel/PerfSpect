<!--
 * Copyright (C) 2021-2025 Intel Corporation
 * SPDX-License-Identifier: BSD-3-Clause
-->
<!DOCTYPE html>
<html lang="en">

<head>
  <title>Intel&reg; PerfSpect</title>
  <link rel="icon" type="image/x-icon" href="https://www.intel.com/favicon.ico" />
  <meta charset="utf-8" />
  <meta name="viewport" content="initial-scale=1, width=device-width" />
  <script src="https://unpkg.com/react@18.3.1/umd/react.development.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/react-dom@18.3.1/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@mui/material@5.16.7/umd/material-ui.development.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.3.3/echarts.min.js"
    integrity="sha512-2L0h0GhoIHQEjti/1KwfjcbyaTHy+hPPhE1o5wTCmviYcPO/TD9oZvUxFQtWvBkCSTIpt+fjsx1CCx6ekb51gw=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <!-- Fonts to support Material Design -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" />
  <!-- Icons to support Material Design -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
</head>

<body>
  <div id="root"></div>
  <script type="text/babel">
    const {
      colors,
      CssBaseline,
      ThemeProvider,
      Container,
      createTheme,
      Typography,
      Button,
      IconButton,
      ButtonGroup,
      Slider,
      Grid,
      Box,
      Tab,
      Dialog,
      Alert,
      Snackbar,
      Link,
      Tabs,
      TextField,
      Icon,
      Table,
      TableBody,
      TableCell,
      TableContainer,
      TableHead,
      TableRow,
      Tooltip,
      Paper,
    } = MaterialUI;

    // Create a theme instance.
    const theme = createTheme({
      typography: {
        fontSize: 14,
        h2: {
          fontSize: "2.5rem",
        },
        fontFamily: [
          "-apple-system",
          "BlinkMacSystemFont",
          '"Segoe UI"',
          "Roboto",
          '"Helvetica Neue"',
          "Arial",
          "sans-serif",
          '"Apple Color Emoji"',
          '"Segoe UI Emoji"',
          '"Segoe UI Symbol"',
        ].join(","),
      },
      palette: {
        mode: 'light',
      },
    });

    function ReactECharts({ option, style, settings, loading, theme }) {
      const chartRef = React.useRef("null");

      React.useEffect(() => {
        // Initialize chart
        let chart;
        if (chartRef.current !== null) {
          chart = echarts.init(chartRef.current, theme);
        }

        // Add chart resize listener
        // ResizeObserver is leading to a bit janky UX
        function resizeChart() {
          chart.resize();
        }
        window.addEventListener("resize", resizeChart);

        // Return cleanup function
        return () => {
          chart.dispose();
          window.removeEventListener("resize", resizeChart);
        };
      }, [theme]);

      React.useEffect(() => {
        // Update chart
        if (chartRef.current !== null) {
          const chart = echarts.getInstanceByDom(chartRef.current);
          chart.setOption(option, settings);
        }
      }, [option, settings, theme]); // Whenever theme changes we need to add option and setting due to it being deleted in cleanup function

      React.useEffect(() => {
        // Update chart
        if (chartRef.current !== null) {
          const chart = echarts.getInstanceByDom(chartRef.current);
          // eslint-disable-next-line @typescript-eslint/no-unused-expressions
          loading === true ? chart.showLoading() : chart.hideLoading();
        }
      }, [loading, theme]);

      return (
        <div
          ref={chartRef}
          style={{ width: "100%", height: "100%", ...style }}
        />
      );
      }

    function TabPanel(props) {
      const { children, value, index, ...other } = props;

      return (
        <div
          role="tabpanel"
          hidden={value !== index}
          id={`simple-tabpanel-${index}`}
          aria-labelledby={`simple-tab-${index}`}
          {...other}
        >
          {value === index && (
            <div style={{ height: "100%" }}>{children}</div>
          )}
        </div>
      );
    }

    function App() {
      const [systemTabs, setSystemTabs] = React.useState(0);
      const [openlink, setOpenlink] = React.useState(true);
      const [maxdiff, set_maxdiff] = React.useState(0);
      const [mindiff, set_mindiff] = React.useState(0);
      
      const handleChange = (event, newSystemTabs) => {
        setSystemTabs(newSystemTabs);
      };

      const handleCloselink = () => {
        setOpenlink(false)
      };

      const all_metrics = <<.ALLMETRICS>>
      const [current_metrics, setCurrent_metrics] = React.useState(JSON.parse(JSON.stringify(all_metrics)));
      const description = <<.DESCRIPTION>>
      const metadata = <<.METADATA>>
      const system_info = <<.SYSTEMINFO>>
      const base_line = {
        xAxis: {
          type: "category",
          data: <<.TIMESTAMPS>>,
          name: "time (s)",
          min: "dataMin",
          max: "dataMax",
          boundaryGap: false, // ensure the chart starts at the first data point
          axisLabel: {
            rotate: 45,
          }
        },
        yAxis: {},
        tooltip: {
          trigger: 'axis',
          valueFormatter: (value) => value.toFixed(2),
        },
        legend: {},
      }

      let level1tma = {
        ...base_line,
        series: [
          {
            name: "Front-end",
            type: 'line',
            data: <<.TMAFRONTEND>>,
          },
          {
            name: "Back-end",
            type: 'line',
            data: <<.TMABACKEND>>,
          },
          {
            name: "Retiring",
            type: 'line',
            data: <<.TMARETIRING>>,
          },
          {
            name: "Bad Speculation",
            type: 'line',
            data: <<.TMABADSPECULATION>>,
          },
        ]
      }

      let cpu_util = {
        ...base_line,
        series: [
          {
            type: 'line',
            data: <<.CPUUTIL>>,
          }
        ]
      }

      let cpi = {
        ...base_line,
        series: [
          {
            type: 'line',
            data: <<.CPIDATA>>,
          }
        ]
      }

      let cpu_freq = {
        ...base_line,
        series: [
          {
            type: 'line',
            data: <<.CPUFREQ>>,
          }
        ]
      }

      let numa = {
        ...base_line,
        series: [
          {
            type: 'line',
            data: <<.REMOTENUMA>>,
          }
        ]
      }

      let cache = {
        ...base_line,
        series: [
          {
            name: "L1D",
            type: 'line',
            data: <<.L1DATA>>,
          },
          {
            name: "L2",
            type: 'line',
            data: <<.L2DATA>>,
          },
          {
            name: "LLC Data",
            type: 'line',
            data: <<.LLCDATA>>,
          },
        ]
      }

      let memory = {
        ...base_line,
        series: [
          {
            name: "Read",
            type: 'line',
            data: <<.READDATA>>,
          },
          {
            name: "Write",
            type: 'line',
            data: <<.WRITEDATA>>,
          },
          {
            name: "Total",
            type: 'line',
            data: <<.TOTALDATA>>,
          },
        ]
      }

      let package_power = {
        ...base_line,
        series: [
          {
            type: 'line',
            data: <<.PKGPOWER>>,
          }
        ]
      }

      let dram_power = {
        ...base_line,
        series: [
          {
            type: 'line',
            data: <<.DRAMPOWER>>,
          }
        ]
      }


      const diffreport = (e) => {
        let reader = new FileReader();
        reader.onload = (e) => {
          let new_metrics = JSON.parse(e.target.result.split("\n").filter(e => e.includes("const all_metrics ="))[0].split("const all_metrics =")[1])
          let copy = JSON.parse(JSON.stringify(current_metrics))
          let temp_mindiff = 0
          let temp_maxdiff = 0
          for (const metric of copy) {
            for (const other_metric of new_metrics) {
              if (metric[0] === other_metric[0]) {
                metric.other = other_metric[1]
                if (other_metric[1] < metric[1]) {
                  metric.diff = ((other_metric[1] / metric[1]) - 1) * 100
                } else {
                  metric.diff = ((metric[1] / other_metric[1]) - 1) * -100
                }
                if (temp_maxdiff == 0 || temp_maxdiff < metric.diff) {
                  temp_maxdiff = metric.diff
                }
                if (temp_mindiff == 0 || temp_mindiff > metric.diff) {
                  temp_mindiff = metric.diff
                }
              }
            }
          }
          set_maxdiff(temp_maxdiff)
          set_mindiff(temp_mindiff)
          setCurrent_metrics(copy)
        };

        reader.readAsText(e.target.files[0]);
      }



      return (
        <div>
          <Box display="flex" justifyContent="center" width="100%" sx={{ zIndex: 10, borderBottom: 1, borderColor: "divider", position: 'fixed', bgcolor: 'background.paper' }}>
            <Tabs
              value={systemTabs}
              onChange={handleChange}
              variant="scrollable"
            >
              <Tab label="TMAM" />
              <Tab label="CPU" />
              <Tab label="Memory" />
              <Tab label="Power" />
              <Tab label="All Metrics" />
              <Tab label="System Info" />
              <Tab label="Metadata" />
            </Tabs>
          </Box>
          <div style={{ padding: "80px 24px 24px 24px" }}>
            <TabPanel
              value={systemTabs}
              index={0}
            >
              <Grid container style={{ padding: "0px 0px 24px 0px" }}>
                <Grid item xs={5}>
                  <Typography variant="h2">
                    Top-down Microarchitecture Analysis Method (TMAM)
                  </Typography>
                  <ul>
                    <li>
                      <Typography variant="body1">
                        The Front-end is responsible for fetching the program code
                        represented in architectural instructions and decoding
                        them into one or more low-level hardware operations called
                        micro-ops (uOps).
                      </Typography>
                    </li>
                    <li>
                      <Typography variant="body1">
                        The Back-end is responsible for monitoring when uOp's data
                        operands are available and executing the uOp in an
                        available execution unit.
                      </Typography>
                    </li>
                    <li>
                      <Typography variant="body1">
                        Retirement is where results of the uOp are committed to
                        the architectural state (CPU registers or written back to
                        memory).
                      </Typography>
                    </li>
                    <li>
                      <Typography variant="body1">
                        Usually, most uOps pass completely through the pipeline
                        and retire, but sometimes speculatively fetched uOps may
                        get cancelled before retirement – like in the case of
                        mis-predicted branches.
                      </Typography>
                    </li>
                    <li>
                      <a href="https://www.intel.com/content/www/us/en/develop/documentation/vtune-cookbook/top/methodologies/top-down-microarchitecture-analysis-method.html">
                        Learn more here
                      </a>
                    </li>
                  </ul>
                </Grid>
                <Grid item xs={7}>
                  <ReactECharts style={{ minHeight: "400px" }} option={{
                    tooltip: {},
                    series: {
                      nodeClick: false,
                      type: "sunburst",
                      radius: [60, "90%"],
                      itemStyle: {
                        borderRadius: 7,
                        borderWidth: 2,
                      },
                      data: [
                      {
			  name: "<<.FRONTEND_LABEL>>",
			  value: Math.round(<<.FRONTEND>> * 10) / 10,
                          children:[
                            {
			      name: "<<.FETCHBANDWIDTH_LABEL>>",
			      value: Math.round(<<.FETCHBANDWIDTH>> * 10) / 10,
                            },
                            {
			      name: "<<.FETCHLATENCY_LABEL>>",
			      value: Math.round(<<.FETCHLATENCY>> * 10) / 10,
                            },
                          ]
                        },
                        {
			  name: "<<.BADSPECULATION_LABEL>>",
			  value: Math.round(<<.BADSPECULATION>> * 10) / 10,
                          children: [
                            {
			      name: "<<.BRANCHMISPREDICTS_LABEL>>",
			      value: Math.round(<<.BRANCHMISPREDICTS>> * 10) / 10,
                            },
                            {
			      name: "<<.MACHINECLEARS_LABEL>>",
			      value: Math.round(<<.MACHINECLEARS>> * 10) / 10,
                            },
                          ]
                        },
                        {
			  name: "<<.BACKEND_LABEL>>",
			  value: Math.round(<<.BACKEND>> * 10) / 10,
                          children: [
                            {
			      name: "<<.CORE_LABEL>>",
			      value: Math.round(<<.COREDATA>> * 10) / 10,
                            },
                            {
			      name: "<<.MEMORY_LABEL>>",
			      value: Math.round(<<.MEMORY>> * 10) / 10,
                            },
                          ],
                        },
                        {
			  name: "<<.RETIRING_LABEL>>",
			  value: Math.round(<<.RETIRING>> * 10) / 10,
                          children: [
                            {
			      name: "<<.LIGHTOPS_LABEL>>",
			      value: Math.round(<<.LIGHTOPS>> * 10) / 10,
                            },
                            {
			      name: "<<.HEAVYOPS_LABEL>>",
			      value: Math.round(<<.HEAVYOPS>> * 10) / 10,
                            },
                          ]
                        },
                      ],
                      radius: [20, "100%"],
                      label: {
                        rotate: "radial",
                      },
                    },
                  }} />
                </Grid>
              </Grid>
              <Grid container>
                <Grid item xs={5}>
                  <Typography variant="h2">
                    TMA Level 1
                  </Typography>
                  <Typography variant="body1">
                    Here, we show the TMA Front-end, Back-end, Retiring and Bad Speculation percentages over the collection period.
                  </Typography>
                </Grid>
                <Grid item xs={7}>
                  <ReactECharts style={{ minHeight: "250px" }} option={level1tma} />
                </Grid>
              </Grid>
            </TabPanel>
            <TabPanel
              value={systemTabs}
              index={1}
            >
              <Grid container>
                <Grid item xs={5}>
                  <Typography variant="h2">
                    CPU utilization
                  </Typography>
                  <Typography variant="body1">
                    Percentage of time spent in the active CPU power state C0. When a core is not being utilized it can go into lower power states to reduce idle energy consumption.
                  </Typography>
                </Grid>
                <Grid item xs={7}>
                  <ReactECharts style={{ minHeight: "250px" }} option={cpu_util} />
                </Grid>
              </Grid>
              <Grid container>
                <Grid item xs={5}>
                  <Typography variant="h2">
                    CPI
                  </Typography>
                  <Typography variant="body1">
                    Cycles per instruction retired; indicating how much time each executed instruction took; in units of cycles. Often this metric shows how efficiently applications are using the underlying hardware. A lower CPI could indicate that instructions are not hitting bottlenecks and retiring quickly.
                  </Typography>
                </Grid>
                <Grid item xs={7}>
                  <ReactECharts style={{ minHeight: "250px" }} option={cpi} />
                </Grid>
              </Grid>
              <Grid container>
                <Grid item xs={5}>
                  <Typography variant="h2">
                    CPU operating frequency (in GHz)
                  </Typography>
                  <Typography variant="body1">
                    This is the speed of the CPU clock. Higher frequencies allow faster execution. Usually servers are able to change their frequency based on utilization to conserve energy or turbo for short periods of time to boost performance.
                  </Typography>
                </Grid>
                <Grid item xs={7}>
                  <ReactECharts style={{ minHeight: "250px" }} option={cpu_freq} />
                </Grid>
              </Grid>
            </TabPanel>
            <TabPanel
              value={systemTabs}
              index={2}
            >
              <Grid container>
                <Grid item xs={5}>
                  <Typography variant="h2">
                    Memory Bandwidth
                  </Typography>
                  <Typography variant="body1">
                    Here, DDR memory bandwidth is broken down into reads, writes and total (read + write) in MB/sec.
                  </Typography>
                </Grid>
                <Grid item xs={7}>
                  <ReactECharts style={{ minHeight: "250px" }} option={memory} />
                </Grid>
              </Grid>
              <Grid container>
                <Grid item xs={5}>
                  <Typography variant="h2">
                    Remote DRAM reads %
                  </Typography>
                  <Typography variant="body1">
                    The memory reads that miss the last level cache (LLC) and are addressed to another socket's DRAM (remote DRAM) as a percentage of total memory read accesses. This does not include LLC prefetches.
                  </Typography>
                </Grid>
                <Grid item xs={7}>
                  <ReactECharts style={{ minHeight: "250px" }} option={numa} />
                </Grid>
              </Grid>
              <Grid container>
                <Grid item xs={5}>
                  <Typography variant="h2">
                    Cache MPI (misses per instruction)
                  </Typography>
                  <Typography variant="body1">
                    The ratio of the number of requests missing cache to the total number of completed instructions, at each level of cache (L1, L2 and LLC)
                  </Typography>
                </Grid>
                <Grid item xs={7}>
                  <ReactECharts style={{ minHeight: "250px" }} option={cache} />
                </Grid>
              </Grid>
            </TabPanel>
            <TabPanel
              value={systemTabs}
              index={3}
            >
              <Grid container>
                <Grid item xs={5}>
                  <Typography variant="h2">
                    Package Power
                  </Typography>
                  <Typography variant="body1">
                    The amount of power, in watts, consumed by the CPU package on the system. We provide this metric primarily for determining if system performance is being adversely affected by power throttling, although it can also be used to calculate energy consumption.
                  </Typography>
                </Grid>
                <Grid item xs={7}>
                  <ReactECharts style={{ minHeight: "250px" }} option={package_power} />
                </Grid>
              </Grid>
              <Grid container>
                <Grid item xs={5}>
                  <Typography variant="h2">
                    DRAM Power
                  </Typography>
                  <Typography variant="body1">
                    The amount of power, in watts, consumed by the DRAM on the system. We provide this metric primarily for determining if system performance is being adversely affected by power throttling, although it can also be used to calculate energy consumption.
                  </Typography>
                </Grid>
                <Grid item xs={7}>
                  <ReactECharts style={{ minHeight: "250px" }} option={dram_power} />
                </Grid>
              </Grid>
            </TabPanel>
            <TabPanel
              value={systemTabs}
              index={4}
            >
              <TextField 
                id="outlined-basic" 
                onChange={diffreport} 
                inputProps={{ accept: '.html' }} 
                fullWidth 
                label="Compare with other *_metrics_summary.html" 
                InputLabelProps={{ shrink: true }} 
                sx={{ paddingBottom: "24px" }} 
                type="file" 
                variant="outlined" 
              />
              <TableContainer component={Paper} sx={{ width: "fit-content" }}>
                <Table size="small" style={{ tableLayout: 'auto' }}>
                  <TableHead>
                    <TableRow>
                      <TableCell>Metric</TableCell>
                      <TableCell>Mean</TableCell>
                      <TableCell>Min</TableCell>
                      <TableCell>Max</TableCell>
                      <TableCell>Stddev</TableCell>
                      {current_metrics[0].hasOwnProperty("other") && <TableCell sx={{ fontStyle: 'italic' }}>Other Mean</TableCell>}
                      {current_metrics[0].hasOwnProperty("other") && <TableCell>Diff</TableCell>}
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {current_metrics.map((row) => {
                      // Check if this metric has exceed its threshold
                      const exceedsThreshold = row[5] == "Yes";
                      return (
                        <TableRow
                          hover={true}
                          key={row[0]}
                          sx={{ 
                            '&:last-child td, &:last-child th': { border: 0 },
                            // Highlight the entire row if mean value exceeds its specific threshold
                            backgroundColor: exceedsThreshold ? 'rgba(255, 255, 0, 0.2)' : 'inherit'
                          }}
                        >
                          <TableCell sx={{ fontFamily: 'Monospace' }} component="th" scope="row" >
                            <Tooltip 
                              title={description.hasOwnProperty(row[0]) ? description[row[0]] : ""} 
                              componentsProps={{
                                tooltip: {
                                  sx: {
                                    fontSize: '1.0rem',  // Increase tooltip font size
                                    padding: '8px 12px',  // Add some padding for better readability
                                    bgcolor: 'rgba(97, 97, 97, 0.92)',  // Darker background
                                    color: '#ffffff',  // White text for contrast
                                    fontWeight: 400,  // Normal font weight
                                    boxShadow: '0px 2px 6px rgba(0, 0, 0, 0.2)'  // Add shadow for depth
                                  }
                                }
                              }}
                            >
                              {description.hasOwnProperty(row[0]) && <IconButton sx={{ padding: "0 8px 0 0" }}>
                                <Icon>info</Icon>
                              </IconButton>}
                              {!description.hasOwnProperty(row[0]) && <IconButton sx={{ padding: "0 8px 0 0" }} disabled>
                                <Icon>info</Icon>
                              </IconButton>}
                            </Tooltip>
                            {(() => {
                              // Calculate indendation from the metric level value in column 8 (index 7)
                              // The lowest level is 1
                              const level = row[7] ? Number(row[7]) : 1;
                              const indentationLevel = level > 1 ? level - 1 : 0;
                              
                              // Create indentation based on hierarchy level
                              const indentation = indentationLevel > 0 ? 
                                <span style={{
                                  paddingLeft: `${indentationLevel * 16}px`,
                                  borderLeft: indentationLevel > 0 ? '1px dotted #aaa' : 'none',
                                  marginLeft: indentationLevel > 0 ? '4px' : '0',
                                }}>
                                  {indentationLevel > 0 && <Icon 
                                    sx={{ 
                                      fontSize: '0.8rem', 
                                      verticalAlign: 'middle',
                                      color: '#666',
                                      marginRight: '4px'
                                    }}
                                  >
                                    subdirectory_arrow_right
                                  </Icon>}
                                </span> : null;
                              
                              return (
                                <React.Fragment>
                                  {indentation}
                                  {row[0]}
                                </React.Fragment>
                              );
                            })()}
                          </TableCell>
                          <TableCell 
                            sx={{ 
                              fontFamily: 'Monospace', 
                              fontWeight: exceedsThreshold ? 'bold' : 'normal',
                              backgroundColor: exceedsThreshold ? 'rgba(255, 235, 59, 0.4)' : 'inherit'
                            }} 
                            align="right"
                          >
                            {Number(row[1]).toFixed(4)}
                            {exceedsThreshold && 
                              <Tooltip 
                                title={`${row[6]}`}
                                componentsProps={{
                                  tooltip: {
                                    sx: {
                                      fontSize: '1.0rem',  // Increased tooltip font size
                                      padding: '8px 12px',  // Add some padding for better readability
                                      bgcolor: 'rgba(255, 235, 59, 0.9)',  // Slightly yellow background to match warning context
                                      color: '#222222',  // Grey text for better contrast on yellow
                                      fontWeight: 400  // Normal font weight
                                    }
                                  }
                                }}
                              >
                                <IconButton size="small" sx={{ padding: "0 0 0 4px" }}>
                                  <Icon fontSize="small">warning</Icon>
                                </IconButton>
                              </Tooltip>
                            }
                          </TableCell>
                          <TableCell sx={{ fontFamily: 'Monospace' }} align="right">
                            {Number(row[2]).toFixed(4)}
                          </TableCell>
                          <TableCell sx={{ fontFamily: 'Monospace' }} align="right">
                            {Number(row[3]).toFixed(4)}
                          </TableCell>
                          <TableCell sx={{ fontFamily: 'Monospace' }} align="right">
                            {Number(row[4]).toFixed(4)}
                          </TableCell>
                          {row.hasOwnProperty("other") && <TableCell sx={{ fontFamily: 'Monospace', fontStyle: 'italic' }} align="right">
                            {Number(row["other"]).toFixed(4)}
                          </TableCell>}
                          {row.hasOwnProperty("other") && <TableCell align="right" sx={{ fontFamily: 'Monospace', backgroundColor: (row.diff > 0 ? "rgba(255,0,0," + (row.diff / maxdiff * .5) + ")" : "rgba(0,0,255," + (row.diff / mindiff * .5) + ")") }}>
                            {Math.round(Number(row["diff"]))}%
                          </TableCell>}
                        </TableRow>
                      );
                    })}
                  </TableBody>
                </Table>
              </TableContainer>
              <Box sx={{ marginTop: "16px" }}>
                <Alert 
                  severity="warning" 
                  sx={{ 
                    marginBottom: "24px",
                    backgroundColor: 'rgba(255, 255, 0, 0.2)',
                    '& .MuiAlert-icon': {
                      color: 'rgba(0, 0, 0, 0.7)'
                    },
                    '& .MuiAlert-message': {
                      color: 'rgba(0, 0, 0, 0.7)'
                    }
                  }}
              >
                Metrics with a mean value exceeding their threshold formula are highlighted in yellow, indicating potential performance issues or anomalies that may require further investigation. Hover over the warning icon next to the mean value for more information.
              </Alert>
              </Box>
            </TabPanel>
            <TabPanel
              value={systemTabs}
              index={5}
            >
            <TableContainer component={Paper} sx={{ width: "fit-content" }}>
                <Table size="small" style={{ tableLayout: 'auto' }}>
                  <TableHead>
                    <TableRow>
                      <TableCell>Key</TableCell>
                      <TableCell>Value</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {system_info.map(([key, value]) => (
                      <TableRow key={key}>
                      <TableCell sx={{ fontFamily: 'Monospace' }} component="th" scope="row" >
                        {JSON.stringify(key)}
                      </TableCell>
                      <TableCell sx={{ fontFamily: 'Monospace' }} align="left">
                        {JSON.stringify(value)}
                      </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>
            </TabPanel>
            <TabPanel
              value={systemTabs}
              index={6}
            >
            <TableContainer component={Paper} sx={{ width: "fit-content" }}>
                <Table size="small" style={{ tableLayout: 'auto' }}>
                  <TableHead>
                    <TableRow>
                      <TableCell>Key</TableCell>
                      <TableCell>Value</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {Object.entries(metadata).sort(([key1], [key2]) => key1.localeCompare(key2)).map(([key, value]) => (
                      <TableRow key={key}>
                      <TableCell sx={{ fontFamily: 'Monospace' }} component="th" scope="row" >
                        {JSON.stringify(key)}
                      </TableCell>
                      <TableCell sx={{ fontFamily: 'Monospace' }} align="left">
                        {JSON.stringify(value)}
                      </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>
            </TabPanel>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(
      <ThemeProvider theme={theme}>
        {/* CssBaseline kickstart an elegant, consistent, and simple baseline to build upon. */}
        <CssBaseline />
        <App />
      </ThemeProvider>
    );
  </script>
</body>

</html>
